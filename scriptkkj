--========== PRE EXEC (CORRIGIDO) ==========

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local lp = Players.LocalPlayer

local TEXTO_PATENTE = "discord.gg/tX4uZ64eDw"
local TEXTO_DIVISAO = "script feito por nob999"

local rainbowConn

local function getTextLabel(surfaceGui)
    if not surfaceGui then return nil end
    for _, v in ipairs(surfaceGui:GetDescendants()) do
        if v:IsA("TextLabel") then
            return v
        end
    end
end

local function applyRainbow(character)
    if rainbowConn then
        rainbowConn:Disconnect()
        rainbowConn = nil
    end

    local head = character:WaitForChild("Head", 5)
    if not head then return end

    local patenteTL = getTextLabel(head:FindFirstChild("Patente"))
    local divisaoTL = getTextLabel(head:FindFirstChild("Divisão"))
    local nomeTL    = getTextLabel(head:FindFirstChild("Nome"))

    if patenteTL then patenteTL.Text = TEXTO_PATENTE end
    if divisaoTL then divisaoTL.Text = TEXTO_DIVISAO end

    rainbowConn = RunService.RenderStepped:Connect(function()
        local c = Color3.fromHSV((tick() * 0.35) % 1, 1, 1)
        if patenteTL then patenteTL.TextColor3 = c end
        if divisaoTL then divisaoTL.TextColor3 = c end
        if nomeTL then nomeTL.TextColor3 = c end
    end)
end

if lp.Character then
    task.spawn(applyRainbow, lp.Character)
end

lp.CharacterAdded:Connect(function(char)
    task.wait(0.5)
    applyRainbow(char)
end)

--========== FIM PRE EXEC ==========--


--// Rayfield UI
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local TextChatService = game:GetService("TextChatService")

--=====================================================
-- WINDOW
--=====================================================
local Window = Rayfield:CreateWindow({
    Name = "foder eb v2",
    LoadingTitle = "foder eb v2",
    LoadingSubtitle = "feito por nob999 | discord.gg/tX4uZ64eDw",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "foder-eb-v2",
        FileName = "config"
    },
    Discord = {
        Enabled = true,
        Invite = "tX4uZ64eDw",
        RememberJoins = true
    },
    KeySystem = false
})

--=====================================================
-- TAB 1
--=====================================================
local TabFuck = Window:CreateTab("fuck the game", 4483362458)
TabFuck:CreateSection("money")

TabFuck:CreateButton({
    Name = "puxar dinheiro infinito",
    Callback = function()
        Rayfield:Notify({
            Title = "money",
            Content = "puxando dinheiro...",
            Duration = 2
        })

        local args = {
            "-99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999",
            "BuyMilitaryPass"
        }

        pcall(function()
            ReplicatedStorage.Remotes.Events.Economy.DecrementMoney:FireServer(unpack(args))
        end)

        Rayfield:Notify({
            Title = "money",
            Content = "finalizado",
            Duration = 2
        })
    end
})

TabFuck:CreateButton({
    Name = "foder dinheiro de geral",
    Callback = function()
        local TransferRemote =
            ReplicatedStorage.Modules.Packages.Knit.Services
            .EconomyService.RE.Transfer

        Rayfield:Notify({
            Title = "server",
            Content = "processando jogadores...",
            Duration = 3
        })

        for i, plr in ipairs(Players:GetPlayers()) do
            Rayfield:Notify({
                Title = "transfer",
                Content = "enviando dinheiro para "..plr.Name,
                Duration = 2
            })

            pcall(function()
                TransferRemote:FireServer(plr.Name, "99999999999999999999")
            end)

            task.wait(16)
        end

        Rayfield:Notify({
            Title = "finalizado",
            Content = "todos receberam o dinheiro",
            Duration = 4
        })
    end
})
-- ================= FOOTER =================
TabFuck:CreateParagraph({
    Title = "foder eb",
    Content = "Versão v2\nRayfield UI\nmade by nob999"
})

--=====================================================
-- TAB CORE
--=====================================================
local TabCore = Window:CreateTab("break system", 4483362458)
TabCore:CreateSection("core")

-- REMOVE "ANTICHEAT" (CHEATBLOCKER)
TabCore:CreateButton({
    Name = "remove anti cheat",
    Callback = function()

 local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local rawmt = getrawmetatable(game)
setreadonly(rawmt, false)

local oldIndex = rawmt.__index

rawmt.__index = newcclosure(function(self, key)
    if key == "WalkSpeed" then
        if typeof(self) == "Instance"
            and self:IsA("Humanoid")
            and self.Parent
            and self.Parent == LocalPlayer.Character then
            return 16
        end
    end

    return oldIndex(self, key)
end)

setreadonly(rawmt, true)
        local s, e = pcall(function()
            local sp = game:GetService("StarterPlayer")
            local scr = sp:WaitForChild("StarterPlayerScripts"):FindFirstChild("Server")
            if scr then
                local target = scr:FindFirstChild("CheatBlocker")
                if target then
                    target:Destroy()
                    Rayfield:Notify({Title="Script", Content="CheatBlocker removido!", Duration=2})
                else
                    Rayfield:Notify({Title="Script", Content="CheatBlocker não encontrado", Duration=2})
                end
            end
        end)
        if not s then
            Rayfield:Notify({Title="Erro", Content=tostring(e), Duration=3})
        end
    end
})

-- CHAT LOGS REAL (HISTÓRICO)
TabCore:CreateButton({
    Name = "chat logs",
    Callback = function()
      local TextChatService = game:GetService("TextChatService")
        local StarterGui = game:GetService("StarterGui")

        Rayfield:Notify({
            Title = "Chat",
            Content = "Reativando histórico do chat...",
            Duration = 2
        })

        pcall(function()
            -- força uso do novo chat
            TextChatService.ChatVersion = Enum.ChatVersion.TextChatService
            
            -- garante que o chat está visível
            StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)

            -- tenta forçar o window
            local chatWindow = TextChatService:FindFirstChild("ChatWindowConfiguration")
            if chatWindow then
                chatWindow.Enabled = true
            end
        end)

        task.wait(1)

        Rayfield:Notify({
            Title = "Chat ajustado ✅",
            Content = "O histórico do chat deve aparecer novamente",
            Duration = 3
        })
    end
})

--// TPWalk Forward Toggle
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local TPWalkEnabled = false
local TPWalkSpeed = 16 -- velocidade fixa

-- FUNÇÃO TP PARA FRENTE
local function tpForward()
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    hrp.CFrame = hrp.CFrame + hrp.CFrame.LookVector * TPWalkSpeed * RunService.RenderStepped:Wait()
end

-- LOOP PRINCIPAL
RunService.RenderStepped:Connect(function()
    if TPWalkEnabled then
        tpForward()
    end
end)

--// UI Rayfield
TabCore:CreateToggle({
    Name = "TPWalk Forward",
    CurrentValue = false,
    Callback = function(state)
        TPWalkEnabled = state
    end
})

--=====================================================
-- TAB COMBAT
--=====================================================
local TabCombat = Window:CreateTab("player", 4483362458)
TabCombat:CreateSection("player")

-- ESP
local ESPEnabled = false
local ESPFolder = Instance.new("Folder")
ESPFolder.Name = "ESP_FOLDER"
ESPFolder.Parent = gethui and gethui() or game:GetService("CoreGui")

local function updateESP()
    if not ESPEnabled then return end
    ESPFolder:ClearAllChildren()

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            local h = Instance.new("Highlight")
            h.Adornee = plr.Character
            h.FillColor = Color3.fromRGB(255,0,0)
            h.FillTransparency = 0.4
            h.OutlineTransparency = 0
            h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            h.Parent = ESPFolder
        end
    end
end

task.spawn(function()
    while true do
        if ESPEnabled then updateESP() end
        task.wait(2)
    end
end)

TabCombat:CreateToggle({
    Name = "esp",
    CurrentValue = false,
    Callback = function(v)
        ESPEnabled = v
        if not v then ESPFolder:ClearAllChildren() end
    end
})

-- VELOCIDADE
TabCombat:CreateSlider({
    Name = "velocidade",
    Range = {16,250},
    Increment = 1,
    CurrentValue = 16,
    Callback = function(v)
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then hum.WalkSpeed = v end
    end
})

-- TAB ARMAS
local TabItems = Window:CreateTab("fuck weapons", 4483362458)
TabItems:CreateSection("armas")

local armaEscolhida = "M4A1"

TabItems:CreateDropdown({
    Name = "selecionar arma",
    Options = {"M4A1","HK416","G36C","AK-47","M16","MP5","MP40"},
    CurrentOption = "M4A1",
    Callback = function(v)
        armaEscolhida = type(v) == "table" and v[1] or v
    end
})

TabItems:CreateButton({
    Name = "executar arma",
    Callback = function()
        pcall(function()
            ReplicatedStorage.Modules.Packages.Knit.Services
            .ItemShopService.RF.BuyOrEquip:InvokeServer(armaEscolhida)
        end)

        Rayfield:Notify({
            Title = "arma",
            Content = "executado: "..armaEscolhida,
            Duration = 2
        })
    end
})

--================ A I M B O T =================--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- CONFIG PADRÃO
local AimbotEnabled = false
local TeamCheck = true
local WallCheck = true
local AimFOV = 30
local Smoothness = 0.15
local TargetMode = "Auto" -- Auto / Head / Torso

-- AJUSTES
local HEAD_OFFSET = 0.15     -- corrige mira acima da cabeça
local MAX_VERTICAL = 0.6     -- anti overshoot vertical

--================ FUNÇÕES =================--


local function GetTargetPart(char)
    if TargetMode == "Head" then
        return char:FindFirstChild("Head")
    elseif TargetMode == "Torso" then
        return char:FindFirstChild("HumanoidRootPart")
    else
        -- AUTO: perto = torso, longe = head
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local head = char:FindFirstChild("Head")
        if not hrp or not head then return head or hrp end

        local dist = (Camera.CFrame.Position - hrp.Position).Magnitude
        return dist < 25 and hrp or head
    end
end


local function GetAimPosition(part)
    local origin = Camera.CFrame.Position
    local dir = part.Position - origin

    if not WallCheck then
        return part.Position - Vector3.new(0, HEAD_OFFSET, 0)
    end

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character}

    local result = workspace:Raycast(origin, dir, params)
    if result and result.Instance:IsDescendantOf(part.Parent) then
        return result.Position
    end

    return nil
end

-- Escolhe melhor alvo no FOV
local function GetClosestTarget()
    local closestPart
    local smallestAngle = AimFOV

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer
        and plr.Character
        and plr.Character:FindFirstChild("Humanoid")
        and plr.Character.Humanoid.Health > 0 then

            if TeamCheck and plr.Team == LocalPlayer.Team then
                continue
            end

            local part = GetTargetPart(plr.Character)
            if not part then continue end

            local camLook = Camera.CFrame.LookVector
            local dir = (part.Position - Camera.CFrame.Position).Unit
            local angle = math.deg(math.acos(camLook:Dot(dir)))

            if angle < smallestAngle then
                local aimPos = GetAimPosition(part)
                if aimPos then
                    smallestAngle = angle
                    closestPart = part
                end
            end
        end
    end

    return closestPart
end

--================ LOOP =================--

RunService.RenderStepped:Connect(function()
    if not AimbotEnabled then return end

    local target = GetClosestTarget()
    if not target then return end

    local aimPos = GetAimPosition(target)
    if not aimPos then return end

    -- Anti overshoot vertical
    local camPos = Camera.CFrame.Position
    local deltaY = math.clamp(aimPos.Y - camPos.Y, -MAX_VERTICAL, MAX_VERTICAL)
    local correctedPos = Vector3.new(aimPos.X, camPos.Y + deltaY, aimPos.Z)

    local newCF = CFrame.new(camPos, correctedPos)
    Camera.CFrame = Camera.CFrame:Lerp(newCF, Smoothness)
end)

--================ UI RAYFIELD =================--

TabItems:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Callback = function(v)
        AimbotEnabled = v
    end
})

TabItems:CreateToggle({
    Name = "Team Check",
    CurrentValue = true,
    Callback = function(v)
        TeamCheck = v
    end
})

TabItems:CreateToggle({
    Name = "Wall Check",
    CurrentValue = true,
    Callback = function(v)
        WallCheck = v
    end
})

TabItems:CreateSlider({
    Name = "FOV",
    Range = {5, 180},
    Increment = 1,
    CurrentValue = 30,
    Callback = function(v)
        AimFOV = v
    end
})

TabItems:CreateSlider({
    Name = "Smooth",
    Range = {0.01, 1},
    Increment = 0.01,
    CurrentValue = 0.15,
    Callback = function(v)
        Smoothness = v
    end
})

TabItems:CreateDropdown({
    Name = "Target Mode",
    Options = {"Auto", "Head", "Torso"},
    CurrentOption = "Auto",
    Callback = function(v)
        TargetMode = type(v) == "table" and v[1] or v
    end
})
